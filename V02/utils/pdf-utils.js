/**
 * BCFSleuth PDF Utilities
 * Shared PDF generation utilities for consistent formatting across all PDF reports
 *
 * This module provides:
 * - Standardized cover page generation
 * - Text wrapping for PDF content
 * - Consistent filename generation
 * - Common PDF setup and formatting
 *
 * Usage:
 *   PDFUtils.addStandardizedCoverPage(pdf, 'Grid Report', imageCount, projectName);
 *   const wrappedText = PDFUtils.wrapTextForPDF(pdf, longText, maxWidth);
 */

class PDFUtils {
  /**
   * Add standardized cover page to PDF document
   * Consistent across all report types (Grid, Detailed, Executive Summary)
   * @param {jsPDF} pdf - PDF document instance
   * @param {string} reportType - Type of report (e.g., 'Grid Report', 'Detailed Report')
   * @param {number} imageCount - Total number of images in report
   * @param {string} projectName - Project name for the report
   * @param {Object} stats - Optional statistics object for additional details
   */
  static addStandardizedCoverPage(
    pdf,
    reportType,
    imageCount,
    projectName,
    stats = null
  ) {
    console.log(`ðŸ“„ Creating standardized cover page for ${reportType}`);

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    // Main title - consistent across all reports
    pdf.setFontSize(24);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`BCF ${reportType}`, pageWidth / 2, 60, { align: 'center' });

    // Project name - consistent formatting
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`Project: ${projectName}`, pageWidth / 2, 85, { align: 'center' });

    // Generation date - consistent positioning
    pdf.setFontSize(12);
    const today = new Date().toLocaleDateString();
    pdf.text(`Generated: ${today}`, pageWidth / 2, 105, { align: 'center' });

    // Image count - consistent across all reports
    pdf.text(`Total Images: ${imageCount}`, pageWidth / 2, 125, {
      align: 'center',
    });

    // Project Statistics section - enhanced for all report types
    if (stats && Object.keys(stats).length > 0) {
      let currentY = 160;

      // Section header
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Project Statistics', pageWidth / 2, currentY, {
        align: 'center',
      });
      currentY += 25;

      // Statistics content
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(11);

      // Format statistics based on what's available
      const statLines = [];

      if (stats.projects) {
        statLines.push(
          `Projects: ${
            Array.isArray(stats.projects)
              ? stats.projects.join(', ')
              : stats.projects
          }`
        );
      }

      if (stats.statusCount) {
        statLines.push(
          `Status Breakdown: ${Object.entries(stats.statusCount)
            .map(([status, count]) => `${status} (${count})`)
            .join(', ')}`
        );
      }

      if (stats.priorityCount) {
        statLines.push(
          `Priority Breakdown: ${Object.entries(stats.priorityCount)
            .map(([priority, count]) => `${priority} (${count})`)
            .join(', ')}`
        );
      }

      if (stats.authorCount) {
        const topAuthors = Object.entries(stats.authorCount)
          .slice(0, 3)
          .map(([author, count]) => `${author} (${count})`)
          .join(', ');
        statLines.push(`Top Authors: ${topAuthors}`);
      }

      // Add each statistic line with proper spacing
      statLines.forEach((line) => {
        // Check for page overflow
        if (currentY > pageHeight - 80) {
          pdf.addPage();
          currentY = 40;
        }

        pdf.text(line, pageWidth / 2, currentY, { align: 'center' });
        currentY += 15;
      });
    }

    // Footer - consistent across all reports
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'italic');
    pdf.text('Generated by BCFSleuth', pageWidth / 2, pageHeight - 30, {
      align: 'center',
    });

    console.log(`âœ… Standardized cover page created for ${reportType}`);
  }

  /**
   * Wrap text to fit within specified width for PDF
   * Handles word breaking and ensures text fits properly
   * @param {jsPDF} pdf - PDF document instance
   * @param {string} text - Text to wrap
   * @param {number} maxWidth - Maximum width in mm
   * @returns {string[]} - Array of wrapped lines
   */
  static wrapTextForPDF(pdf, text, maxWidth) {
    if (!text || text.trim() === '') {
      return [''];
    }

    const words = text.toString().trim().split(' ');
    const lines = [];
    let currentLine = '';

    words.forEach((word) => {
      const testLine = currentLine ? `${currentLine} ${word}` : word;

      try {
        const testWidth = pdf.getTextWidth(testLine);

        if (testWidth <= maxWidth || currentLine === '') {
          currentLine = testLine;
        } else {
          if (currentLine) {
            lines.push(currentLine);
          }
          currentLine = word;
        }
      } catch (error) {
        // Fallback if getTextWidth fails - use character count estimation
        if (testLine.length <= 80 || currentLine === '') {
          currentLine = testLine;
        } else {
          if (currentLine) {
            lines.push(currentLine);
          }
          currentLine = word;
        }
      }
    });

    if (currentLine) {
      lines.push(currentLine);
    }

    return lines.length > 0 ? lines : [''];
  }

  /**
   * Generate consistent PDF filename
   * @param {string} projectName - Project name
   * @param {string} reportType - Type of report (Grid, Detailed, Summary)
   * @param {string} date - Date string (optional, defaults to today)
   * @returns {string} - Generated filename
   */
  static generatePDFFilename(projectName, reportType, date = null) {
    const sanitizedProject = this.sanitizeFilename(projectName);
    const sanitizedReport = reportType.replace(/\s+/g, '_');
    const dateStr = date || new Date().toISOString().split('T')[0];

    return `${sanitizedProject}_BCF_${sanitizedReport}_Report_${dateStr}.pdf`;
  }

  /**
   * Sanitize string for use in filename
   * @param {string} str - Input string
   * @returns {string} - Sanitized filename-safe string
   */
  static sanitizeFilename(str) {
    if (!str) return 'Unknown';

    return str
      .replace(/[<>:"/\\|?*]/g, '_') // Replace invalid filename characters
      .replace(/\s+/g, '_') // Replace spaces with underscores
      .replace(/_+/g, '_') // Replace multiple underscores with single
      .replace(/^_|_$/g, '') // Remove leading/trailing underscores
      .substring(0, 50); // Limit length
  }

  /**
   * Setup standard PDF document properties
   * @param {jsPDF} pdf - PDF document instance
   * @param {string} title - Document title
   * @param {string} subject - Document subject
   * @returns {jsPDF} - PDF document with properties set
   */
  static setupPDFDocument(pdf, title, subject) {
    // Set document properties
    pdf.setProperties({
      title: title,
      subject: subject,
      author: 'BCFSleuth',
      creator: 'BCFSleuth',
      producer: 'BCFSleuth',
    });

    return pdf;
  }

  /**
   * Add page header with consistent formatting
   * @param {jsPDF} pdf - PDF document instance
   * @param {string} headerText - Header text
   * @param {number} pageNumber - Current page number
   * @param {number} totalPages - Total pages (optional)
   */
  static addPageHeader(pdf, headerText, pageNumber, totalPages = null) {
    const pageWidth = pdf.internal.pageSize.getWidth();
    const margin = 15;

    // Save current font settings
    const currentFontSize = pdf.internal.getFontSize();
    const currentFont = pdf.internal.getFont();

    // Set header font
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');

    // Add header text
    pdf.text(headerText, pageWidth / 2, margin + 10, { align: 'center' });

    // Add page number
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    const pageText = totalPages
      ? `Page ${pageNumber} of ${totalPages}`
      : `Page ${pageNumber}`;
    pdf.text(pageText, pageWidth - margin, margin + 10, { align: 'right' });

    // Add separator line
    pdf.setLineWidth(0.5);
    pdf.line(margin, margin + 15, pageWidth - margin, margin + 15);

    // Restore font settings
    pdf.setFontSize(currentFontSize);
    pdf.setFont(currentFont.fontName, currentFont.fontStyle);
  }

  /**
   * Calculate optimal image dimensions while preserving aspect ratio
   * @param {number} originalWidth - Original image width
   * @param {number} originalHeight - Original image height
   * @param {number} maxWidth - Maximum allowed width
   * @param {number} maxHeight - Maximum allowed height
   * @returns {Object} - {width, height} optimal dimensions
   */
  static calculateImageDimensions(
    originalWidth,
    originalHeight,
    maxWidth,
    maxHeight
  ) {
    if (originalWidth === 0 || originalHeight === 0) {
      return { width: maxWidth * 0.8, height: maxHeight * 0.8 };
    }

    const aspectRatio = originalWidth / originalHeight;
    let finalWidth, finalHeight;

    // Calculate dimensions that fit within bounds while preserving aspect ratio
    if (aspectRatio > maxWidth / maxHeight) {
      // Width-constrained
      finalWidth = Math.min(maxWidth, maxWidth * 0.95);
      finalHeight = finalWidth / aspectRatio;
    } else {
      // Height-constrained
      finalHeight = Math.min(maxHeight, maxHeight * 0.95);
      finalWidth = finalHeight * aspectRatio;
    }

    // Ensure minimum readable size
    const minSize = 20;
    if (finalWidth < minSize) finalWidth = minSize;
    if (finalHeight < minSize) finalHeight = minSize;

    return { width: finalWidth, height: finalHeight };
  }

  /**
   * Add image to PDF with error handling and fallback
   * @param {jsPDF} pdf - PDF document instance
   * @param {string} imageData - Base64 image data
   * @param {string} imageType - Image MIME type
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} maxWidth - Maximum image width
   * @param {number} maxHeight - Maximum image height
   * @returns {Promise<Object>} - {success: boolean, dimensions: {width, height}}
   */
  static async addImageToPDF(
    pdf,
    imageData,
    imageType,
    x,
    y,
    maxWidth,
    maxHeight
  ) {
    try {
      // Determine format for jsPDF
      let format = 'JPEG';
      if (imageType.includes('png')) {
        format = 'PNG';
      } else if (imageType.includes('gif')) {
        format = 'GIF';
      } else if (imageType.includes('webp')) {
        format = 'WEBP';
      }

      // Get image dimensions using temporary image element
      const img = new Image();
      const dimensions = await new Promise((resolve) => {
        img.onload = () => {
          const calculated = this.calculateImageDimensions(
            img.width,
            img.height,
            maxWidth,
            maxHeight
          );
          resolve(calculated);
        };

        img.onerror = () => {
          resolve({ width: maxWidth * 0.8, height: maxHeight * 0.8 });
        };

        img.src = `data:${imageType};base64,${imageData}`;
      });

      // Center the image if it's smaller than available space
      const imageX = x + (maxWidth - dimensions.width) / 2;
      const imageY = y + (maxHeight - dimensions.height) / 2;

      // Add image to PDF
      pdf.addImage(
        `data:${imageType};base64,${imageData}`,
        format,
        imageX,
        imageY,
        dimensions.width,
        dimensions.height
      );

      return { success: true, dimensions };
    } catch (error) {
      console.warn('Error adding image to PDF:', error);

      // Add placeholder rectangle if image fails
      pdf.setFillColor(240, 240, 240);
      pdf.rect(x, y, maxWidth, maxHeight, 'F');

      // Add error text
      pdf.setFontSize(12);
      pdf.setTextColor(100, 100, 100);
      pdf.text('Image not available', x + maxWidth / 2, y + maxHeight / 2, {
        align: 'center',
        baseline: 'middle',
      });
      pdf.setTextColor(0, 0, 0); // Reset text color

      return {
        success: false,
        dimensions: { width: maxWidth, height: maxHeight },
      };
    }
  }

  /**
   * Truncate text to specified length with ellipsis
   * @param {string} text - Text to truncate
   * @param {number} maxLength - Maximum length
   * @returns {string} - Truncated text
   */
  static truncateText(text, maxLength) {
    if (!text) return '';
    const str = text.toString().trim();
    if (str.length <= maxLength) return str;

    // Try to break at word boundary near the limit
    const truncated = str.substring(0, maxLength);
    const lastSpace = truncated.lastIndexOf(' ');

    if (lastSpace > maxLength * 0.75) {
      return truncated.substring(0, lastSpace) + '...';
    } else {
      return truncated + '...';
    }
  }
}

// Export for use in other modules
window.PDFUtils = PDFUtils;

// Also support ES6 module exports if available
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { PDFUtils };
}
